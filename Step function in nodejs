
































Step 1 : Create one S3 bucket 
Step 2 : Zip all below .js files and upload in S3 bucket:

receiveorder.js:
exports.handler = (event, context, callback) => {
    // TODO implement
    console.log('Order Received:'+"Product:"+event.pid+" ,Quantity:"+event.quantity);
    if(event.quantity < 5){
        callback(null, {"inventoryExists":true,"pid":event.pid});
    }else{
        callback(null, {"inventoryExists":false,"pid":event.pid});
    }
    
};

chargeCustomer.js:
exports.handler = (event, context, callback) => {

    callback(null, {"chargeCustomer":true,"pid":event.pid});
};

declineOrder.js:
exports.handler = (event, context, callback) => {
    // TODO implement
    console.log("Decline Order:inventoryExists:"+event.inventoryExists);
    callback(null, {"declineOrder":true,"pid":event.pid});
};

notifyProcurement.js:
exports.handler = (event, context, callback) => {

    callback(null, {"notifyProcurement":true,"pid":event.pid});
};

processOrder.js:
exports.handler = (event, context, callback) => {
    // TODO implement
    console.log("Processing order:inventoryExists:"+event.inventoryExists)
    callback(null, {"processOrder":true,"pid":event.pid});
};

sendNotification.js:
exports.handler = (event, context, callback) => {

    callback(null, {"sendNotification":true,"pid":event.pid});
};

shipOrder.js:
exports.handler = (event, context, callback) => {

    callback(null, {"shipOrder":true,"pid":event.pid});
};

updateInventory.js:
exports.handler = (event, context, callback) => {
    callback(null, {"updateInventory":true,"pid":event.pid});
};

updateOrderStatus.js:
exports.handler = (event, context, callback) => {

    callback(null, {"updateOrderStatus":true,"pid":event.pid});
};


Step 3 : lambda-functions-CloudFormation.txt:
	This is basic template to create lambda function through Cloud Formation Service.  We will upload this file in Cloud Formation Service using AWS console, It will take some time for creation.
	
	This file first create one role with has trust policy that allows lambda to assume this role (means which is specific to allow, creation of lambda function.)
	
	Creating lambda function in this file, we have to mention the S3 bucket name and executable (which is uploaded in S3 bucket) and
	Runtime language and timeout.
	
	Note : Change lambda function (Resource) name, Bucket Name, Executable name , Runtime language and timeout as per you.
		Role which we want to give to this lambda.
		HANDLER name where the code of lambda function resides.
		
		Like "Handler" : "receiveorder.handler", : 'receiveorder' is file name where is the lambda function and 'handler' is the method name in that class file.
	
		"processorder.zip" : which has all lambda function code.
	
	
	
{
  "AWSTemplateFormatVersion": "2010-09-09",
  "Resources": {
  
	"LambdaExecutionRole": {
	 "Type": "AWS::IAM::Role",
	 "Properties": {
		"AssumeRolePolicyDocument": {
		   "Version" : "2012-10-17",
		   "Statement": [ {
			  "Effect": "Allow",
			  "Principal": {
				 "Service": "lambda.amazonaws.com"
			  },
			  "Action": [ "sts:AssumeRole" ]
		   } ]
		},
		"Path": "/"
		}
	},
	
    "ReceiveOrder": {
      "Type": "AWS::Lambda::Function",
      "Properties": {
        "Handler": "receiveorder.handler",
        "Role": { "Fn::GetAtt" : ["LambdaExecutionRole", "Arn"] },
        "Code": {
          "S3Bucket": "orderprocessing-stepfunction-bucket",
          "S3Key": "processorder.zip"
        },
        "Runtime": "nodejs8.10",
        "Timeout": "25"
      }
    },
    
    "ProcessOrder": {
      "Type": "AWS::Lambda::Function",
      "Properties": {
        "Handler": "processorder.handler",
        "Role": { "Fn::GetAtt" : ["LambdaExecutionRole", "Arn"] },
        "Code": {
          "S3Bucket": "orderprocessing-stepfunction-bucket",
          "S3Key": "processorder.zip"
        },
        "Runtime": "nodejs8.10",
        "Timeout": "25"
      }
    },
    
    "DeclineOrder": {
      "Type": "AWS::Lambda::Function",
      "Properties": {
        "Handler": "declineorder.handler",
        "Role": { "Fn::GetAtt" : ["LambdaExecutionRole", "Arn"] },
        "Code": {
          "S3Bucket": "orderprocessing-stepfunction-bucket",
          "S3Key": "processorder.zip"
        },
        "Runtime": "nodejs8.10",
        "Timeout": "25"
      }
    },
 
    "UpdateInventory": {
      "Type": "AWS::Lambda::Function",
      "Properties": {
        "Handler": "updateinventory.handler",
        "Role": { "Fn::GetAtt" : ["LambdaExecutionRole", "Arn"] },
        "Code": {
          "S3Bucket": "orderprocessing-stepfunction-bucket",
          "S3Key": "processorder.zip"
        },
        "Runtime": "nodejs8.10",
        "Timeout": "25"
      }
    },
      
    "ChargeCustomer": {
      "Type": "AWS::Lambda::Function",
      "Properties": {
        "Handler": "chargecustomer.handler",
        "Role": { "Fn::GetAtt" : ["LambdaExecutionRole", "Arn"] },
        "Code": {
          "S3Bucket": "orderprocessing-stepfunction-bucket",
          "S3Key": "processorder.zip"
        },
        "Runtime": "nodejs8.10",
        "Timeout": "25"
      }
    },    
      
    "ShipOrder": {
      "Type": "AWS::Lambda::Function",
      "Properties": {
        "Handler": "shiporder.handler",
        "Role": { "Fn::GetAtt" : ["LambdaExecutionRole", "Arn"] },
        "Code": {
          "S3Bucket": "orderprocessing-stepfunction-bucket",
          "S3Key": "processorder.zip"
        },
        "Runtime": "nodejs8.10",
        "Timeout": "25"
      }
    },
      
    "NotifyProcurement": {
      "Type": "AWS::Lambda::Function",
      "Properties": {
        "Handler": "notifyprocurement.handler",
        "Role": { "Fn::GetAtt" : ["LambdaExecutionRole", "Arn"] },
        "Code": {
          "S3Bucket": "orderprocessing-stepfunction-bucket",
          "S3Key": "processorder.zip"
        },
        "Runtime": "nodejs8.10",
        "Timeout": "25"
      }
    },
      
    "SendNotification": {
      "Type": "AWS::Lambda::Function",
      "Properties": {
        "Handler": "sendnotification.handler",
        "Role": { "Fn::GetAtt" : ["LambdaExecutionRole", "Arn"] },
        "Code": {
          "S3Bucket": "orderprocessing-stepfunction-bucket",
          "S3Key": "processorder.zip"
        },
        "Runtime": "nodejs8.10",
        "Timeout": "25"
      }
    },
      
    "UpdateOrderStatus": {
      "Type": "AWS::Lambda::Function",
      "Properties": {
        "Handler": "updateorderstatus.handler",
        "Role": { "Fn::GetAtt" : ["LambdaExecutionRole", "Arn"] },
        "Code": {
          "S3Bucket": "orderprocessing-stepfunction-bucket",
          "S3Key": "processorder.zip"
        },
        "Runtime": "nodejs8.10",
        "Timeout": "25"
      }
    }  
  }
}


Step 4 :How to upload 'lambda-functions-CloudFormation.txt' in CloudFormation Services:

Open Cloud foundation -> create stack -> upload file -> give Stack name -> next -> next -> create








Step 5 :Create Step Functions:
This is basic template to create step function based on our requirement. 

Open Step Functions -> Create State machines -> Write state function code and refresh the state machines pictorial representation 
To get it reflected -> give the name of state machine -> 
IAM role for executions -> select 'Create an IAM role for me' -> give name ->  create .

Note : you donâ€™t need to add any policy to this role. AWS will take care of this step functions.

For example :




Our Step Function Code: StepFunctions.json:
This is our code, which state machine function starts from "ReceiveOrder", means first "ReceiveOrder" lambda will execute first 
which has 'States' like an array, which takes three field :
	1. 'Type' :
	2. 'Resources' : This should be the respective lambda ARN name .
	3. 'Next' : This should be next lambda name which needs to be executed based on conditions.

Note : Change all above three fields based on your code/requirements.

{
  "Comment": "Order Processing Business Process",
  "StartAt": "ReceiveOrder",
  "States": {
  
    "ReceiveOrder": {
      "Type": "Task",
      "Resource": "arn:aws:lambda:REGION:ACCOUNT_ID:function:FUNCTION_NAME",
      "Next": "CheckInventory"
    },
    
    "CheckInventory": {
      "Type" : "Choice",
      "Choices": [
        {
          "Variable": "$.inventoryExists",
          "BooleanEquals": true,
          "Next": "ProcessOrder"
        },
        {
          "Variable": "$.inventoryExists",
          "BooleanEquals": false,
          "Next": "DeclineOrderBranch"
        }
      ]
    },

    "ProcessOrder": {
      "Comment": "------------Inventory Exists - Process Order-------------",
      "Type" : "Task",
      "Resource": "arn:aws:lambda:REGION:ACCOUNT_ID:function:OnFirstMatch",
      "Next": "UpdateInventory"
    },
    
    "UpdateInventory": {
      "Type" : "Task",
      "Resource": "arn:aws:lambda:REGION:ACCOUNT_ID:function:OnFirstMatch",
      "Next": "ChargeCustomer"
    },
        
    "ChargeCustomer": {
      "Type" : "Task",
      "Resource": "arn:aws:lambda:REGION:ACCOUNT_ID:function:OnFirstMatch",
      "Next": "ShipOrder"
    },
    
    "ShipOrder": {
      "Type" : "Task",
      "Resource": "arn:aws:lambda:REGION:ACCOUNT_ID:function:OnFirstMatch",
      "Next": "SendNotification"
    },
    
    "DeclineOrderBranch": {
      "Comment": "------------No Inventory - Decline Order-------------",
      "Type": "Parallel",
      "Branches": [
        {
          "StartAt": "DeclineOrder",
          "States": {
            "DeclineOrder": {
              "Type": "Task",
              "Resource":
                "arn:aws:lambda:us-east-1:123456789012:function:AddressFinder",
              "End": true
            }
          }
        },
        {
          "StartAt": "NotifyProcurement",
          "States": {
            "NotifyProcurement": {
              "Type": "Task",
              "Resource":
                "arn:aws:lambda:us-east-1:123456789012:function:PhoneFinder",
              "End": true
            }
          }
        }
      ],
      "Next": "SendNotification"
    },
    
    "SendNotification": {
      "Comment": "------------Continue General Processing-------------", 
      "Type" : "Task",
      "Resource": "arn:aws:lambda:REGION:ACCOUNT_ID:function:OnFirstMatch",
      "Next": "UpdateOrderStatus"
    },
        
    "UpdateOrderStatus": {
      "Type" : "Task",
      "Resource": "arn:aws:lambda:REGION:ACCOUNT_ID:function:OnFirstMatch",
      "End": true
    }

  }
}



Our modified Step Function Code: StepFunctions.json:

{
  "Comment": "Order Processing Business Process",
  "StartAt": "ReceiveOrder",
  "States": {
  
    "ReceiveOrder": {
      "Type": "Task",
      "Resource": "arn:aws:lambda:us-east-1:079141114588:function:ProcessOrderStack-ReceiveOrder-YS37JY6M7PMC",
      "Next": "CheckInventory"
    },
    
    "CheckInventory": {
      "Type" : "Choice",
      "Choices": [
        {
          "Variable": "$.inventoryExists",
          "BooleanEquals": true,
          "Next": "ProcessOrder"
        },
        {
          "Variable": "$.inventoryExists",
          "BooleanEquals": false,
          "Next": "DeclineOrderBranch"
        }
      ]
    },

    "ProcessOrder": {
      "Comment": "------------Inventory Exists - Process Order-------------",
      "Type" : "Task",
      "Resource": "arn:aws:lambda:us-east-1:079141114588:function:ProcessOrderStack-ProcessOrder-184HSJSMLO5U7",
      "Next": "UpdateInventory"
    },
    
    "UpdateInventory": {
      "Type" : "Task",
      "Resource": "arn:aws:lambda:us-east-1:079141114588:function:ProcessOrderStack-UpdateInventory-4OQ1O61AP156",
      "Next": "ChargeCustomer"
    },
        
    "ChargeCustomer": {
      "Type" : "Task",
      "Resource": "arn:aws:lambda:us-east-1:079141114588:function:ProcessOrderStack-ChargeCustomer-1SMK502APO1GI",
      "Next": "ShipOrder"
    },
    
    "ShipOrder": {
      "Type" : "Task",
      "Resource": "arn:aws:lambda:us-east-1:079141114588:function:ProcessOrderStack-ShipOrder-1H6RCQS48APS3",
      "Next": "SendNotification"
    },
    
    "DeclineOrderBranch": {
      "Comment": "------------No Inventory - Decline Order-------------",
      "Type": "Parallel",
      "Branches": [
        {
          "StartAt": "DeclineOrder",
          "States": {
            "DeclineOrder": {
              "Type": "Task",
              "Resource":
                "arn:aws:lambda:us-east-1:079141114588:function:ProcessOrderStack-DeclineOrder-DJH3UPGC4I2B",
              "End": true
            }
          }
        },
        {
          "StartAt": "NotifyProcurement",
          "States": {
            "NotifyProcurement": {
              "Type": "Task",
              "Resource":
                "arn:aws:lambda:us-east-1:079141114588:function:ProcessOrderStack-NotifyProcurement-2E7495HEW75R",
              "End": true
            }
          }
        }
      ],
      "Next": "SendNotification"
    },
    
    "SendNotification": {
      "Comment": "------------Continue General Processing-------------", 
      "Type" : "Task",
      "Resource": "arn:aws:lambda:us-east-1:079141114588:function:ProcessOrderStack-SendNotification-ZOGORW8UR01P",
      "Next": "UpdateOrderStatus"
    },
        
    "UpdateOrderStatus": {
      "Type" : "Task",
      "Resource": "arn:aws:lambda:us-east-1:079141114588:function:ProcessOrderStack-UpdateOrderStatus-1NTTZ24XEYABZ",
      "End": true
    }

  }
}


Step 6 :Test State Machine:
	
Our Input File based on our requirement and code: This is negative test since our code will fail because we have put the condition  like:

	if(event.quantity < 5){
	        callback(null, {"inventoryExists":true,"pid":event.pid});
	    }else{
	        callback(null, {"inventoryExists":false,"pid":event.pid});
	    }
	
Test1 : JSON:
	
	{
		"pid" : 7,
		"quantity" : 23
	}
	
	
Open created state function -> click on 'Start Execution -> give input in JSON what our code expected -> Start Execution ->






Result :







Test2 : JSON:
	
	{
		"pid" : 2,
		"quantity" : 3
	}
	
	
Result :






Step 7 :Create New role to log our log into CloudLogs:

IAM -> New role -> lambda -> add policy CloudWatchLogsFullAccess -> Next review -> Next review -> give role name . 





Create new policy -> JSON tab : -> put code ->next ->  name of policy -> create 

This simply allows 'StartExecution' on the state machine for any resource 

	
	
Like:
	{
	    "Version": "2012-10-17",
	    "Statement": [
	        {
	            "Sid": "VisualEditor0",
	            "Effect": "Allow",
	            "Action": "states:*",
	            "Resource": "*"
	        }
	    ]
	}
	

Open IAM -> Attach new policy -> find above created one policy.



Create New Lambda to invoke other above created Step Functions through API Gateway :

In 

URL : https://bwphuyyohi.execute-api.us-east-1.amazonaws.com/test/order?pid=9&quantity=7





Step 8 :Trigger State - Machine as batch process - S3 Integration :

We will upload file in S3 bucket, this will call the lambda function and lambda will read the file from S3 bucket and invoke the process.






We need below steps to be done to achieve above functionality .





	1. Update IAM Role :
		We need to add policy to access S3 bucket.
		
		Go to IAM -> Users-> Add User -> Give user name and select Programmatic access
		-> next -> create group -> give group name -> next -> next -> create user.
		
		Always download .csv file of credentials. Or copy like below:
		
		User: HelloLambdaUser
		Access key ID : AKIAINKFQFPDINLWC7TA
		Secret access key: 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
		
		
		Open created group -> go to permissions tab -> attach policy -> click on 'click here' under Inline Policies
		
		
		
		
		
		Click on select of 'Policy Generator'  >
		Select 'AWS Lambda' in AWS Service -> AWS Lambda
		Select 2 Actions : 'InvokeAsync' and 'InvokeFuction'
		
		
		
		
		
		
		Go to specific lambda which you want to give permission to this user and copy ARN and paste under Amazon Resource Name (ARN) like below screen :
		
		
		
		
		Click on add statement -> next -> create policy 
		
		Now go to group -> add users -> select above created user -> done
		 and add below all policy
		
		
		
		
	
	1 . Policy Format :
	
	{
	    "Version": "2012-10-17",
	    "Statement": [
	        {
	            "Effect": "Allow",
	            "Action": [
	                "polly:SynthesizeSpeech",
	                "dynamodb:Query",
	                "dynamodb:Scan",
	                "dynamodb:PutItem",
	                "dynamodb:UpdateItem",
	                "sns:Publish",
	                "s3:PutObject",
	                "s3:PutObjectAcl",
	                "s3:GetBucketLocation",
	                "logs:CreateLogGroup",
	                "logs:CreateLogStream",
	                "logs:PutLogEvents"
	            ],
	            "Resource": [
	                "*"
	            ]
	        }
	    ]
	}
	
		
		
	2. Create Lambda Function using above role and add trigger as S3 and add S3 bucket name.
		and below package :
			i. Zip the below two JS files and upload it into lambda
			ii. Change handler to : invokeorder-s3.handler in lambda function.
		
	aws-sdk-stepfunctions.js :  we have to add this code for aws-sdk support for step functions . This is new functions and not integrated with AWS-SDK production yet.
			
			var AWS = require("aws-sdk");
			AWS.apiLoader.services["stepfunctions"] = {};
			AWS.StepFunctions = AWS.Service.defineService("stepfunctions", [ "2016-11-23" ]);AWS.apiLoader.services["stepfunctions"]["2016-11-23"] = {
			    version: "2.0",
			    metadata: {
			        apiVersion: "2016-11-23",
			        endpointPrefix: "states",
			        jsonVersion: "1.0",
			        protocol: "json",
			        serviceAbbreviation: "AWS SFN",
			        serviceFullName: "AWS Step Functions",
			        signatureVersion: "v4",
			        targetPrefix: "AWSStepFunctions",
			        uid: "states-2016-11-23"
			    },
			    operations: {
			        CreateActivity: {
			            input: {
			                type: "structure",
			                required: [ "name" ],
			                members: {
			                    name: {}
			                }
			            },
			            output: {
			                type: "structure",
			                required: [ "activityArn", "creationDate" ],
			                members: {
			                    activityArn: {},
			                    creationDate: {
			                        type: "timestamp"
			                    }
			                }
			            },
			            idempotent: true
			        },
			        CreateStateMachine: {
			            input: {
			                type: "structure",
			                required: [ "name", "definition", "roleArn" ],
			                members: {
			                    name: {},
			                    definition: {},
			                    roleArn: {}
			                }
			            },
			            output: {
			                type: "structure",
			                required: [ "stateMachineArn", "creationDate" ],
			                members: {
			                    stateMachineArn: {},
			                    creationDate: {
			                        type: "timestamp"
			                    }
			                }
			            },
			            idempotent: true
			        },
			        DeleteActivity: {
			            input: {
			                type: "structure",
			                required: [ "activityArn" ],
			                members: {
			                    activityArn: {}
			                }
			            },
			            output: {
			                type: "structure",
			                members: {}
			            }
			        },
			        DeleteStateMachine: {
			            input: {
			                type: "structure",
			                required: [ "stateMachineArn" ],
			                members: {
			                    stateMachineArn: {}
			                }
			            },
			            output: {
			                type: "structure",
			                members: {}
			            }
			        },
			        DescribeActivity: {
			            input: {
			                type: "structure",
			                required: [ "activityArn" ],
			                members: {
			                    activityArn: {}
			                }
			            },
			            output: {
			                type: "structure",
			                required: [ "activityArn", "name", "creationDate" ],
			                members: {
			                    activityArn: {},
			                    name: {},
			                    creationDate: {
			                        type: "timestamp"
			                    }
			                }
			            }
			        },
			        DescribeExecution: {
			            input: {
			                type: "structure",
			                required: [ "executionArn" ],
			                members: {
			                    executionArn: {}
			                }
			            },
			            output: {
			                type: "structure",
			                required: [ "executionArn", "stateMachineArn", "status", "startDate", "input" ],
			                members: {
			                    executionArn: {},
			                    stateMachineArn: {},
			                    name: {},
			                    status: {},
			                    startDate: {
			                        type: "timestamp"
			                    },
			                    stopDate: {
			                        type: "timestamp"
			                    },
			                    input: {},
			                    output: {}
			                }
			            }
			        },
			        DescribeStateMachine: {
			            input: {
			                type: "structure",
			                required: [ "stateMachineArn" ],
			                members: {
			                    stateMachineArn: {}
			                }
			            },
			            output: {
			                type: "structure",
			                required: [ "stateMachineArn", "name", "definition", "roleArn", "creationDate" ],
			                members: {
			                    stateMachineArn: {},
			                    name: {},
			                    status: {},
			                    definition: {},
			                    roleArn: {},
			                    creationDate: {
			                        type: "timestamp"
			                    }
			                }
			            }
			        },
			        GetActivityTask: {
			            input: {
			                type: "structure",
			                required: [ "activityArn" ],
			                members: {
			                    activityArn: {},
			                    workerName: {}
			                }
			            },
			            output: {
			                type: "structure",
			                members: {
			                    taskToken: {},
			                    input: {}
			                }
			            }
			        },
			        GetExecutionHistory: {
			            input: {
			                type: "structure",
			                required: [ "executionArn" ],
			                members: {
			                    executionArn: {},
			                    maxResults: {
			                        type: "integer"
			                    },
			                    reverseOrder: {
			                        type: "boolean"
			                    },
			                    nextToken: {}
			                }
			            },
			            output: {
			                type: "structure",
			                required: [ "events" ],
			                members: {
			                    events: {
			                        type: "list",
			                        member: {
			                            type: "structure",
			                            required: [ "timestamp", "type", "id" ],
			                            members: {
			                                timestamp: {
			                                    type: "timestamp"
			                                },
			                                type: {},
			                                id: {
			                                    type: "long"
			                                },
			                                previousEventId: {
			                                    type: "long"
			                                },
			                                activityFailedEventDetails: {
			                                    type: "structure",
			                                    members: {
			                                        error: {},
			                                        cause: {}
			                                    }
			                                },
			                                activityScheduleFailedEventDetails: {
			                                    type: "structure",
			                                    members: {
			                                        error: {},
			                                        cause: {}
			                                    }
			                                },
			                                activityScheduledEventDetails: {
			                                    type: "structure",
			                                    required: [ "resource" ],
			                                    members: {
			                                        resource: {},
			                                        input: {},
			                                        timeoutInSeconds: {
			                                            type: "long"
			                                        },
			                                        heartbeatInSeconds: {
			                                            type: "long"
			                                        }
			                                    }
			                                },
			                                activityStartedEventDetails: {
			                                    type: "structure",
			                                    members: {
			                                        workerName: {}
			                                    }
			                                },
			                                activitySucceededEventDetails: {
			                                    type: "structure",
			                                    members: {
			                                        output: {}
			                                    }
			                                },
			                                activityTimedOutEventDetails: {
			                                    type: "structure",
			                                    members: {
			                                        error: {},
			                                        cause: {}
			                                    }
			                                },
			                                executionFailedEventDetails: {
			                                    type: "structure",
			                                    members: {
			                                        error: {},
			                                        cause: {}
			                                    }
			                                },
			                                executionStartedEventDetails: {
			                                    type: "structure",
			                                    members: {
			                                        input: {},
			                                        roleArn: {}
			                                    }
			                                },
			                                executionSucceededEventDetails: {
			                                    type: "structure",
			                                    members: {
			                                        output: {}
			                                    }
			                                },
			                                executionAbortedEventDetails: {
			                                    type: "structure",
			                                    members: {
			                                        error: {},
			                                        cause: {}
			                                    }
			                                },
			                                executionTimedOutEventDetails: {
			                                    type: "structure",
			                                    members: {
			                                        error: {},
			                                        cause: {}
			                                    }
			                                },
			                                lambdaFunctionFailedEventDetails: {
			                                    type: "structure",
			                                    members: {
			                                        error: {},
			                                        cause: {}
			                                    }
			                                },
			                                lambdaFunctionScheduleFailedEventDetails: {
			                                    type: "structure",
			                                    members: {
			                                        error: {},
			                                        cause: {}
			                                    }
			                                },
			                                lambdaFunctionScheduledEventDetails: {
			                                    type: "structure",
			                                    required: [ "resource" ],
			                                    members: {
			                                        resource: {},
			                                        input: {},
			                                        timeoutInSeconds: {
			                                            type: "long"
			                                        }
			                                    }
			                                },
			                                lambdaFunctionStartFailedEventDetails: {
			                                    type: "structure",
			                                    members: {
			                                        error: {},
			                                        cause: {}
			                                    }
			                                },
			                                lambdaFunctionSucceededEventDetails: {
			                                    type: "structure",
			                                    members: {
			                                        output: {}
			                                    }
			                                },
			                                lambdaFunctionTimedOutEventDetails: {
			                                    type: "structure",
			                                    members: {
			                                        error: {},
			                                        cause: {}
			                                    }
			                                },
			                                stateEnteredEventDetails: {
			                                    type: "structure",
			                                    required: [ "name" ],
			                                    members: {
			                                        name: {},
			                                        input: {}
			                                    }
			                                },
			                                stateExitedEventDetails: {
			                                    type: "structure",
			                                    required: [ "name" ],
			                                    members: {
			                                        name: {},
			                                        output: {}
			                                    }
			                                }
			                            }
			                        }
			                    },
			                    nextToken: {}
			                }
			            }
			        },
			        ListActivities: {
			            input: {
			                type: "structure",
			                members: {
			                    maxResults: {
			                        type: "integer"
			                    },
			                    nextToken: {}
			                }
			            },
			            output: {
			                type: "structure",
			                required: [ "activities" ],
			                members: {
			                    activities: {
			                        type: "list",
			                        member: {
			                            type: "structure",
			                            required: [ "activityArn", "name", "creationDate" ],
			                            members: {
			                                activityArn: {},
			                                name: {},
			                                creationDate: {
			                                    type: "timestamp"
			                                }
			                            }
			                        }
			                    },
			                    nextToken: {}
			                }
			            }
			        },
			        ListExecutions: {
			            input: {
			                type: "structure",
			                required: [ "stateMachineArn" ],
			                members: {
			                    stateMachineArn: {},
			                    statusFilter: {},
			                    maxResults: {
			                        type: "integer"
			                    },
			                    nextToken: {}
			                }
			            },
			            output: {
			                type: "structure",
			                required: [ "executions" ],
			                members: {
			                    executions: {
			                        type: "list",
			                        member: {
			                            type: "structure",
			                            required: [ "executionArn", "stateMachineArn", "name", "status", "startDate" ],
			                            members: {
			                                executionArn: {},
			                                stateMachineArn: {},
			                                name: {},
			                                status: {},
			                                startDate: {
			                                    type: "timestamp"
			                                },
			                                stopDate: {
			                                    type: "timestamp"
			                                }
			                            }
			                        }
			                    },
			                    nextToken: {}
			                }
			            }
			        },
			        ListStateMachines: {
			            input: {
			                type: "structure",
			                members: {
			                    maxResults: {
			                        type: "integer"
			                    },
			                    nextToken: {}
			                }
			            },
			            output: {
			                type: "structure",
			                required: [ "stateMachines" ],
			                members: {
			                    stateMachines: {
			                        type: "list",
			                        member: {
			                            type: "structure",
			                            required: [ "stateMachineArn", "name", "creationDate" ],
			                            members: {
			                                stateMachineArn: {},
			                                name: {},
			                                creationDate: {
			                                    type: "timestamp"
			                                }
			                            }
			                        }
			                    },
			                    nextToken: {}
			                }
			            }
			        },
			        SendTaskFailure: {
			            input: {
			                type: "structure",
			                required: [ "taskToken" ],
			                members: {
			                    taskToken: {},
			                    error: {},
			                    cause: {}
			                }
			            },
			            output: {
			                type: "structure",
			                members: {}
			            }
			        },
			        SendTaskHeartbeat: {
			            input: {
			                type: "structure",
			                required: [ "taskToken" ],
			                members: {
			                    taskToken: {}
			                }
			            },
			            output: {
			                type: "structure",
			                members: {}
			            }
			        },
			        SendTaskSuccess: {
			            input: {
			                type: "structure",
			                required: [ "taskToken", "output" ],
			                members: {
			                    taskToken: {},
			                    output: {}
			                }
			            },
			            output: {
			                type: "structure",
			                members: {}
			            }
			        },
			        StartExecution: {
			            input: {
			                type: "structure",
			                required: [ "stateMachineArn" ],
			                members: {
			                    stateMachineArn: {},
			                    name: {},
			                    input: {}
			                }
			            },
			            output: {
			                type: "structure",
			                required: [ "executionArn", "startDate" ],
			                members: {
			                    executionArn: {},
			                    startDate: {
			                        type: "timestamp"
			                    }
			                }
			            },
			            idempotent: true
			        },
			        StopExecution: {
			            input: {
			                type: "structure",
			                required: [ "executionArn" ],
			                members: {
			                    executionArn: {},
			                    error: {},
			                    cause: {}
			                }
			            },
			            output: {
			                type: "structure",
			                required: [ "stopDate" ],
			                members: {
			                    stopDate: {
			                        type: "timestamp"
			                    }
			                }
			            }
			        }
			    },
			    shapes: {},
			    paginators: {
			        GetExecutionHistory: {
			            input_token: "nextToken",
			            output_token: "nextToken",
			            limit_key: "maxResults",
			            result_key: "events"
			        },
			        ListActivities: {
			            input_token: "nextToken",
			            output_token: "nextToken",
			            limit_key: "maxResults",
			            result_key: "activities"
			        },
			        ListExecutions: {
			            input_token: "nextToken",
			            output_token: "nextToken",
			            limit_key: "maxResults",
			            result_key: "executions"
			        },
			        ListStateMachines: {
			            input_token: "nextToken",
			            output_token: "nextToken",
			            limit_key: "maxResults",
			            result_key: "stateMachines"
			        }
			    }
			}
			
			
	invokeorder-s3.js
			
			var AWS = require("aws-sdk");
			require("aws-sdk-stepfunctions");
			
			var stepfunctions = new AWS.StepFunctions();
			var s3 = new AWS.S3();
			exports.handler = (event, context, callback) => {
			
			    // Get the object from the event and show its content type
			    const bucket = event.Records[0].s3.bucket.name;
			  //Key represent the file name.
			    const key = decodeURIComponent(event.Records[0].s3.object.key.replace(/\+/g, ' '));
			    console.log("-------------"+bucket+",----------"+key);
			   
			    const params = {
			        Bucket: bucket,
			        Key: key,
			    };
			
			// now asking to S3 to access the object with bucket name and file name.
			    s3.getObject(params, (err, data) => {
			        if (err) {
			            const message = 'Error getting object ${key} from bucket ${bucket}. Make sure they exist and your bucket is in the same region as this function.';
			            console.log(message);
			            callback(message);
			            
			        } else {
				/*we are parsing the data content into JSON object.
				*/
			                var OrderJson = JSON.parse(data.Body.toString());
			
				// getting content from file and creating one param variable with state machine function and content
				/*Note : we can have 1000+ records in file , so we just need to parse into JSON object in above line.
				Have array instead of variable 'wf_params' and inside traverse the content and store into array
				
				STATE_MACHINE_ARN : this should be exact ARN of STATE_MACHINE
				*/
			                var wf_params = {
			                  stateMachineArn: 'STATE_MACHINE_ARN', /* required */
			                  input: '{"pid":'+OrderJson.pid+',"quantity":'+OrderJson.quantity+'}',
			                  name: 'Execution_Lambda_'+OrderJson.pid
			                };
			
				// calling step function using above param varaible.
			                stepfunctions.startExecution(wf_params, function(err, data) {
			                  if (err) {
			                      console.log(err, err.stack);
			                      callback(null, err);
			                  }
			                  else{
			                      console.log(data);
			                      callback(null, data);
			                  }     
			            });
			        }
			    });
			
			
			};
			
			
		
	
	3. Create S3 Bucket:
		a. Should be in same region in which we lambda created

Go to the created lambda -> add S3 and chose bucket and prefix and suffix so that this lambda will trigger only with specific file, not for all files.


	
	
	

Note : Before execute this step , make sure you have added S3 bucket as trigger in your lambda.
Add notification configuration on the source bucket to request Amazon S3 to publish object-created events to Lambda.
To configure notifications
	1. Open theÂ Amazon S3 console.
	2. Choose the source bucket.
	3. ChooseÂ Properties.
	4. UnderÂ Events, configure a notification with the following settings.
		â—‹ NameÂ â€“Â lambda-trigger.
		â—‹ EventsÂ â€“Â ObjectCreate (All).
		â—‹ Send toÂ â€“Â Lambda function.
		â—‹ Choose your lambda.
		

	4. Create file name 'Process_Order.json' with below contents :
		
		{
		  "pid": 44,
		  "quantity": 12
		}
		
		
	5. Upload above file in S3, and check step function,  step function must be triggered. 
